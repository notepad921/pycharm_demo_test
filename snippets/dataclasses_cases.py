"""
Dataclass scenarios: difference between generated vs explicit __init__.
Verifies that quick-fix constructs keyworded calls and avoids false positives
when __init__ is auto-generated by @dataclass.
"""

from dataclasses import dataclass

# D01 — Parent is @dataclass
@dataclass
class DataParent:
    """Parent dataclass with implicit __init__(id, name='n')."""
    id: int
    name: str = "n"


class DataChildExplicitInit(DataParent):
    """
    Child defines explicit __init__. Quick-fix should call:
    super().__init__(id=id, name=name). D01.
    """
    def __init__(self, id: int, name: str = "n"):
        ...


# D02 — Child is @dataclass, no explicit __init__
class RegularParentWithInit:
    """Regular parent with explicit __init__(x)."""
    def __init__(self, x):
        ...


@dataclass
class DataChildAutoInit(RegularParentWithInit):
    """
    Child dataclass with fields and no explicit __init__ → @dataclass generates it.
    Inspection should NOT trigger. D02.
    """
    x: int


# -----------------------------
# D03 — Dataclass parent with kw_only=True
# -----------------------------
@dataclass(kw_only=True)
class KWOnlyDataParent:
    """
    All fields are keyword-only in generated __init__.
    Quick-fix should build keyworded call: super().__init__(id=id, name=name). D03.
    """
    id: int
    name: str = "n"


class KWOnlyDataChild(KWOnlyDataParent):
    """Child provides explicit __init__; keyworded call is expected. D03."""
    def __init__(self, id: int, name: str = "n"):
        ...
